/**
 * # Core Philosophy
 * This ruleset enforces a user-centric security model where user profiles are publicly readable, but each user has exclusive control over their own data. The primary goal is to secure user profiles while allowing for rapid application development.
 *
 * # Data Structure
 * All user data is stored in a single, top-level collection: `/users/{walletAddress}`. The document ID (`walletAddress`) is the user's Solana wallet public key, which also serves as their unique Firebase Authentication UID. This flat structure ensures that authorization checks are fast and efficient, without needing to access other documents.
 *
 * # Key Security Decisions
 * - **Public Profiles**: User profile data is publicly readable to support features like user discovery and profile viewing. Anyone, including unauthenticated users, can read profile documents.
 * - **Strict Ownership for Writes**: A user can only create, update, or delete the document that corresponds to their own UID. They cannot affect any other user's data.
 * - **Protected Admin Fields**: Certain fields within a user's profile (e.g., `isBanned`, `rankingScore`, `adminNotes`) are designated as admin-only. A regular user is explicitly blocked from modifying these fields on their own profile. Only a designated admin user can modify them.
 * - **No User Listing Deletion**: To prevent accidental mass deletion, there are no rules that allow a `delete` operation on the entire `/users` collection path. Deletion is only permitted on individual documents by their owner.
 *
 * # Denormalization for Authorization
 * The security model relies on the denormalized fact that the document ID in the `/users` collection is the same as the owner's `request.auth.uid`. This direct mapping (`/users/{request.auth.uid}`) is the foundation for all ownership-based rules and completely avoids slow and costly `get()` calls to other documents for authorization purposes.
 *
 * # Structural Segregation
 * This ruleset does not require structural segregation as there is no mixed public/private data at the collection level. All documents within the `/users` collection share the same access control pattern: public read, owner-only write (with admin overrides for specific fields).
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ----------------------------------------------------------------------
    // Helper Functions
    // ----------------------------------------------------------------------

    /**
     * Checks if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the requester's UID matches the provided userId.
     * This is the foundation of the ownership model.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Checks if the requester is the owner of an existing document.
     * CRITICAL: Used for all update and delete operations to prevent
     * acting on documents that don't exist.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * Checks if the requester is the designated admin user.
     * TODO: Replace 'ADMIN_WALLET_PLACEHOLDER' with the actual admin's Solana wallet address / UID.
     */
    function isAdmin() {
      return isSignedIn() && request.auth.uid == 'ADMIN_WALLET_PLACEHOLDER';
    }

    /**
     * Validates that a user creating their own profile document sets the
     * internal 'walletAddress' field correctly to match their auth UID.
     * This enforces relational integrity from the moment of creation.
     */
    function hasValidWalletAddressOnCreate(walletAddress) {
      return request.resource.data.walletAddress == walletAddress;
    }

    /**
     * Ensures that once the 'walletAddress' is set, it cannot be changed.
     * This prevents re-assigning a profile document to a different user.
     */
    function isWalletAddressImmutable() {
      return request.resource.data.walletAddress == resource.data.walletAddress;
    }

    /**
     * Checks if a write request attempts to modify any admin-only fields.
     * This uses `request.writeFields`, which contains the list of fields
     * being modified in an `update` operation.
     */
    function isAttemptingAdminWrite() {
      let adminFields = [
        'rankingScore', 'escrowBalance', 'isBanned', 'isSuspended',
        'suspensionReason', 'warnings', 'adminNotes'
      ];
      return request.writeFields.hasAny(adminFields);
    }

    /**
     * @description
     * Manages user profiles. Profiles are public to read, but a user can only create,
     * update, or delete their own profile document. Administrative fields are
     * protected and can only be modified by a designated admin.
     *
     * @path
     * `/users/{walletAddress}`
     *
     * @allow
     * (get) Any user, authenticated or not, reading the profile at `/users/user123`.
     * (create) An authenticated user with UID 'user123' creating their own profile at `/users/user123`.
     * (update) User 'user123' updating their own 'bio' at `/users/user123`.
     * (update) An admin user updating the 'isBanned' field for user `/users/user123`.
     *
     * @deny
     * (create) User 'user123' attempting to create a profile for someone else at `/users/user456`.
     * (update) User 'user123' attempting to update their own `isBanned` field.
     * (delete) User 'user123' attempting to delete the profile at `/users/user456`.
     *
     * @principle
     * Enforces strict document ownership for writes while allowing public reads.
     * Protects sensitive administrative fields from modification by non-admin users.
     */
    match /users/{walletAddress} {
      allow get, list: if true;

      allow create: if isOwner(walletAddress) && hasValidWalletAddressOnCreate(walletAddress);

      allow update: if (isExistingOwner(walletAddress) && !isAttemptingAdminWrite() && isWalletAddressImmutable()) || (isAdmin() && resource != null);

      allow delete: if isExistingOwner(walletAddress);
    }
    
    /**
     * @description
     * Manages video content. Videos are publicly readable. Only the artist who created
     * the video can create or delete it. An artist can update their own video, but
     * certain fields are admin-only.
     *
     * @path
     * `/videos/{videoId}`
     */
    match /videos/{videoId} {
        allow get, list: if true;

        allow create: if isSignedIn() && request.resource.data.artistId == request.auth.uid;
        
        allow update: if (isOwner(resource.data.artistId) && !isAttemptingAdminVideoWrite()) || isAdmin();
        
        allow delete: if isOwner(resource.data.artistId);
        
        function isAttemptingAdminVideoWrite() {
          let adminFields = [
            'adminFlag', 'isBanned', 'banReason', 'adminReason', 'rankingScore', 'hiddenFromFeed'
          ];
          return request.writeFields.hasAny(adminFields);
        }
    }
    
    // ----------------------------------------------------------------------
    // Gossip Feed Rules
    // ----------------------------------------------------------------------

    match /gossip_posts/{postId} {
      allow read: if true;
      allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
      allow update: if isOwner(resource.data.authorId) || isAdmin(); // e.g. for comment count
      allow delete: if isOwner(resource.data.authorId) || isAdmin();
    }
    
    match /gossip_comments/{commentId} {
      allow read: if true;
      allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
      allow delete: if isOwner(resource.data.authorId) || isAdmin();
    }

    match /gossip_ratings/{ratingId} {
        allow read: if true;
        allow create, update: if isSignedIn() && request.resource.data.raterId == request.auth.uid;
        allow delete: if isOwner(resource.data.raterId);
    }

    match /gossip_user_follows/{followId} {
        allow read: if true;
        allow create: if isSignedIn() && request.resource.data.followerId == request.auth.uid;
        allow delete: if isOwner(resource.data.followerId) || isAdmin();
    }

    match /gossip_messages/{messageId} {
        allow read, delete: if isSignedIn() && (request.auth.uid == resource.data.fromId || request.auth.uid == resource.data.toId);
        allow create: if isSignedIn() && request.resource.data.fromId == request.auth.uid;
    }
    
    match /gossip_service_ads/{adId} {
      allow read: if true;
      allow create, update, delete: if isAdmin();
    }
    
    // ----------------------------------------------------------------------
    // Marketplace Rules
    // ----------------------------------------------------------------------

    match /marketplace_products/{productId} {
        allow read: if true;
        allow create: if isSignedIn() && request.resource.data.sellerId == request.auth.uid;
        allow update: if isOwner(resource.data.sellerId) || isAdmin();
        allow delete: if isOwner(resource.data.sellerId) || isAdmin();
    }

    match /marketplace_orders/{orderId} {
        allow read: if isSignedIn() && (request.auth.uid == resource.data.buyerId || request.auth.uid == resource.data.sellerId || isAdmin());
        allow create: if isOwner(request.resource.data.buyerId);
        allow update: if isOwner(resource.data.sellerId) || isAdmin(); // Seller marks as shipped, admin can update
        allow delete: if isAdmin();
    }

    match /marketplace_reviews/{reviewId} {
        allow read: if true;
        allow create: if isSignedIn() && get(/databases/$(database)/documents/marketplace_orders/$(request.resource.data.orderId)).data.buyerId == request.auth.uid;
        allow update, delete: if isOwner(resource.data.buyerId) || isAdmin();
    }
  }
}
