/**
 * # Core Philosophy
 * This ruleset enforces a user-centric security model where user profiles are publicly readable, but each user has exclusive control over their own data. The primary goal is to secure user profiles while allowing for rapid application development.
 *
 * # Data Structure
 * All user data is stored in a single, top-level collection: `/users/{walletAddress}`. The document ID (`walletAddress`) is the user's Solana wallet public key, which also serves as their unique Firebase Authentication UID. This flat structure ensures that authorization checks are fast and efficient, without needing to access other documents.
 *
 * # Key Security Decisions
 * - **Public Profiles**: User profile data is publicly readable to support features like user discovery and profile viewing. Anyone, including unauthenticated users, can read profile documents.
 * - **Strict Ownership for Writes**: A user can only create, update, or delete the document that corresponds to their own UID. They cannot affect any other user's data.
 * - **Protected Admin Fields**: Certain fields within a user's profile (e.g., `isBanned`, `rankingScore`, `adminNotes`) are designated as admin-only. A regular user is explicitly blocked from modifying these fields on their own profile. Only a designated admin user can modify them.
 * - **No User Listing Deletion**: To prevent accidental mass deletion, there are no rules that allow a `delete` operation on the entire `/users` collection path. Deletion is only permitted on individual documents by their owner.
 *
 * # Denormalization for Authorization
 * The security model relies on the denormalized fact that the document ID in the `/users` collection is the same as the owner's `request.auth.uid`. This direct mapping (`/users/{request.auth.uid}`) is the foundation for all ownership-based rules and completely avoids slow and costly `get()` calls to other documents for authorization purposes.
 *
 * # Structural Segregation
 * This ruleset does not require structural segregation as there is no mixed public/private data at the collection level. All documents within the `/users` collection share the same access control pattern: public read, owner-only write (with admin overrides for specific fields).
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ----------------------------------------------------------------------
    // Helper Functions
    // ----------------------------------------------------------------------

    /**
     * Checks if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the requester's UID matches the provided userId.
     * This is the foundation of the ownership model.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }
    
    function getUserRole(userId) {
        return get(/databases/$(database)/documents/users/$(userId)).data.role;
    }
    
    function isArtist(userId) {
        return getUserRole(userId) == 'artist';
    }


    /**
     * Checks if the requester is the designated admin user.
     * TODO: Replace 'ADMIN_WALLET_PLACEHOLDER' with the actual admin's Solana wallet address / UID.
     */
    function isAdmin() {
      return isSignedIn() && request.auth.uid == 'ADMIN_WALLET_PLACEHOLDER';
    }

    /**
     * Ensures that once the 'walletAddress' is set, it cannot be changed.
     * This prevents re-assigning a profile document to a different user.
     */
    function isWalletAddressImmutable() {
      return request.resource.data.walletAddress == resource.data.walletAddress;
    }

    /**
     * Checks if a write request attempts to modify any admin-only fields.
     * This uses `request.writeFields`, which contains the list of fields
     * being modified in an `update` operation.
     */
    function isAttemptingAdminWrite() {
      let adminFields = [
        'rankingScore', 'escrowBalance', 'isBanned', 'isSuspended',
        'suspensionReason', 'warnings', 'adminNotes'
      ];
      return request.writeFields.hasAny(adminFields);
    }
    
    /**
     * Checks if a write request attempts to modify admin-only video fields.
     */
    function isAttemptingAdminVideoWrite() {
      let adminFields = [
        'adminFlag', 'isBanned', 'banReason', 'adminReason', 'rankingScore', 'hiddenFromFeed'
      ];
      return request.writeFields.hasAny(adminFields);
    }

    // ----------------------------------------------------------------------
    // Collection Rules
    // ----------------------------------------------------------------------

    /**
     * @description
     * Manages user profiles. Profiles are public to read, but a user can only create,
     * update, or delete their own profile document. Administrative fields are
     * protected and can only be modified by a designated admin.
     */
    match /users/{walletAddress} {
      allow get, list: if true;

      allow create: if isOwner(walletAddress);

      allow update: if (isOwner(walletAddress) && !isAttemptingAdminWrite() && isWalletAddressImmutable()) || (isAdmin());

      allow delete: if isOwner(walletAddress) || isAdmin();
    }
    
    // PUBLIC READ-ONLY access for querying the collection.
    // This allows unauthenticated users to see the video feed.
    match /videos {
      allow list: if true;
    }
    
    // SECURE rules for individual video documents.
    match /videos/{videoId} {
      allow get: if true;
      allow create: if isSignedIn() && request.resource.data.artistId == request.auth.uid && isArtist(request.auth.uid);
      allow update: if (isOwner(resource.data.artistId) && !isAttemptingAdminVideoWrite()) || isAdmin();
      allow delete: if isOwner(resource.data.artistId) || isAdmin();
    }
    
    // ----------------------------------------------------------------------
    // Gossip Feed Rules
    // ----------------------------------------------------------------------

    match /gossip_posts/{postId} {
      allow read: if true;
      allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
      allow update: if isOwner(resource.data.authorId) || isAdmin(); // e.g. for comment count
      allow delete: if isOwner(resource.data.authorId) || isAdmin();
    }
    
    match /gossip_comments/{commentId} {
      allow read: if true;
      allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
      allow delete: if isOwner(resource.data.authorId) || isAdmin();
    }

    match /gossip_ratings/{ratingId} {
        allow read: if true;
        allow create, update: if isSignedIn() && request.resource.data.raterId == request.auth.uid;
        allow delete: if isOwner(resource.data.raterId);
    }

    match /gossip_user_follows/{followId} {
        allow read: if true;
        allow create: if isSignedIn() && request.resource.data.followerId == request.auth.uid;
        allow delete: if isOwner(resource.data.followerId) || isAdmin();
    }

    match /gossip_messages/{messageId} {
        allow read, delete: if isSignedIn() && (request.auth.uid == resource.data.fromId || request.auth.uid == resource.data.toId || isAdmin());
        allow create: if isSignedIn() && request.resource.data.fromId == request.auth.uid;
    }
    
    match /gossip_service_ads/{adId} {
      allow read: if true;
      allow create, update, delete: if isAdmin();
    }
    
    // ----------------------------------------------------------------------
    // Marketplace Rules
    // ----------------------------------------------------------------------

    match /marketplace_products/{productId} {
        allow read: if true;
        allow create: if isSignedIn() && request.resource.data.sellerId == request.auth.uid;
        allow update: if isOwner(resource.data.sellerId) || isAdmin();
        allow delete: if isOwner(resource.data.sellerId) || isAdmin();
    }

    match /marketplace_orders/{orderId} {
        allow read: if isSignedIn() && (request.auth.uid == resource.data.buyerId || request.auth.uid == resource.data.sellerId || isAdmin());
        allow create: if isOwner(request.resource.data.buyerId);
        allow update: if isOwner(resource.data.sellerId) || isAdmin(); // Seller marks as shipped, admin can update
        allow delete: if isAdmin();
    }

    match /marketplace_reviews/{reviewId} {
        allow read: if true;
        allow create: if isSignedIn() && get(/databases/$(database)/documents/marketplace_orders/$(request.resource.data.orderId)).data.buyerId == request.auth.uid;
        allow update, delete: if isOwner(resource.data.buyerId) || isAdmin();
    }

    // ----------------------------------------------------------------------
    // Notification Rules
    // ----------------------------------------------------------------------

    match /notifications/{notificationId} {
      // Users can only read, update (mark as read), or delete their own notifications.
      allow read, update, delete: if isSignedIn() && isOwner(resource.data.recipientWallet);
      
      // Notifications are created by backend Cloud Functions, so clients cannot create them directly.
      // However, allowing create if the recipient is the one creating it can be a fallback.
      allow create: if isSignedIn() && isOwner(request.resource.data.recipientWallet);
    }

    // ----------------------------------------------------------------------
    // Engagement Rules (Tips, Votes, Favorites)
    // ----------------------------------------------------------------------
    
    match /tips/{tipId} {
      allow read: if true;
      allow create: if isSignedIn() && request.resource.data.fromWallet == request.auth.uid;
    }

    match /user_votes/{voteId} {
      allow read: if true;
      // Note: To enforce one vote per user per video, a composite index on userId and videoId
      // should be created in Firestore, and a Cloud Function trigger or more complex rules
      // would be needed to check for existence before creation.
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow delete: if isOwner(resource.data.userId);
    }
    
    match /favorites/{favoriteId} {
       allow read, create, delete: if isSignedIn() && request.auth.uid == request.resource.data.userId;
       // A user can only manage their own favorites.
       // The rule for create and delete needs to check the incoming data.
       allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
       allow delete: if isSignedIn() && resource.data.userId == request.auth.uid;
    }
    
    // ----------------------------------------------------------------------
    // Admin-Specific Rules
    // ----------------------------------------------------------------------

    match /warnings/{warningId} {
      allow read, write: if isAdmin();
    }

    match /admin_ads/{adId} {
      allow read: if true;
      allow write: if isAdmin();
    }
    
    // ----------------------------------------------------------------------
    // Referral Program Rules
    // ----------------------------------------------------------------------

    match /referrals/{referralId} {
      // Allow users to read their own referrals
      allow read: if isSignedIn() && isOwner(resource.data.referrerWallet);
      
      // Allow authenticated users to create their own referrals
      allow create: if isSignedIn() && isOwner(request.resource.data.referrerWallet);
    }
  }
}
